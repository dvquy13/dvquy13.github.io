---
title: |
    Implement a RecSys, Chapter 1:<br>
    Introduction and Project Overview
subtitle: "Understanding session-based recommendations and setting up your development environment"
date: "2025-05-24"
categories: [recsys, implement-recsys-series]
image: "../static/recommender%20system.png"
format:
  html:
    code-fold: false
    code-annotations: hover
# draft: true
---

This is the **first chapter** of the tutorial series: Implement a RecSys.
{{< include ../_series-index.qmd >}}

## Introduction

Imagine you're browsing an e-commerce site and notice something remarkable: the recommendations update almost instantly as you click through products. You view a pair of headphones, and suddenly complementary items appear. You check out a laptop, and the "you might also like" section refreshes with relevant accessories. You think to yourself—*"Wow, how do they do that?"* Then curiosity kicks in: How do they capture your evolving intent so quickly? How do they serve personalized suggestions fast enough to feel real-time? How do they handle the complexity of understanding your browsing patterns on the fly?

If you've ever have those questions, this tutorial series is for you. 

Over the next several chapters, I'll walk you through building an end-to-end **recommendation system** that reacts in real-time based on user behavior sequences. We'll go from raw data to a complete recommender system that personalizes recommendations as users interact with your platform.

::: {.callout-note appearance="simple"}
## Enough Talking, Show Me the Code!

If you're familiar with RecSys and just want to see the code, here it is: [https://github.com/dvquy13/recsys-seq-model](https://github.com/dvquy13/recsys-seq-model).
:::

For those who aren't well aware of what a recommender system is, here is a quick recap. Recommender systems are specialized tools designed to suggest items—whether products, content, or services—to users based on what we know about their preferences and behaviors. At their core, they comprise a set of technologies, algorithms, and processes that analyze user interaction signals (clicks, views, purchases, ratings, etc.) to predict what individual users might find relevant or engaging.

:::{.column-page}
![](../static/recommender%20system.png){.lightbox}
:::

From the user's perspective, these systems help uncover content or products they might never have discovered on their own and save time by surfacing the most relevant options up front.

From a business standpoint, the primary goals of a recommender system are to create a sense of "we understand you" for each user and to drive revenue through personalized cross-selling opportunities. By tailoring recommendations to each user, companies can boost engagement and average order value.

In practice, recommender systems power some of the world's largest digital platforms. For example, Amazon's "Frequently Bought Together" suggestions guide shoppers toward complementary products, Facebook uses recommendation algorithms to prioritize posts and ads in users' feeds, and Netflix's home screen is largely driven by personalized movie and show recommendations.

:::{.column-page}
![](../static/recsys-biz-value.gif){.lightbox}
:::


The impact of these systems is profound: According to [this report from McKinsey](https://www.mckinsey.com/industries/retail/our-insights/how-retailers-can-keep-up-with-consumers), roughly 75 percent of Netflix viewing hours come from recommended titles, 35 percent of Amazon's purchases are influenced by its recommendations, and Netflix alone [saves around $1 billion per year](https://dl.acm.org/doi/pdf/10.1145/2843948) through improved user retention and engagement. These metrics underscore why recommender systems have become a critical component of modern digital businesses.

## What You'll Build

By the end of this series, you'll have constructed an end-to-end recommendation system while know how to:
 
- **Design and Train Session-based RecSys models** using PyTorch to **personalizes recommendations in real-time** based on users' recent interaction sequences
- **Track experiments** with MLflow for reproducible ML workflows
- **Serve predictions** through a FastAPI service in conjunction with a vector database and caching
- **Package the project** using Docker and modern ML infrastructure
- **Launch aninteractive demo** with a frontend[^1]

[^1]: Though not covered in this tutorial, there would be example UI code in the repo.

:::{.column-page}
![The Demo](../static/session-based%20retriever%20-%20demo%20v2.gif){.lightbox}
:::

## Target Audience

This tutorial series is designed for:

- **Data Scientists** looking beyond training models and into ML services
- **ML Engineers** building scalable recommendation systems
- **Backend Developers** interested in ML/RecSys architecture
- **Anyone** curious about a modern and real-time end-to-end RecSys project

All in all, it's good to have some basic knowledge of Machine Learning and Python to follow along.

## Session-Based vs Traditional Recommendations

### Traditional Collaborative Filtering

Traditional recommendation systems often rely on collaborative filtering, which uses historical user-item interaction matrices to find similar users or items. While effective, these approaches have limitations:

- **Static representations**: User preferences are treated as fixed
- **Cold start problems**: Difficulty with new users or items
- **Limited temporal understanding**: Doesn't capture evolving user interests within a session

### Session-Based Recommendations

Session-based recommendation systems address these limitations by:

- **Modeling sequences**: Understanding the order and timing of user interactions
- **Capturing short-term intent**: Focusing on recent behaviors within a session
- **Handling anonymity**: Working even without persistent user identifiers
- **Real-time adaptation**: Continuously updating recommendations as users interact

## Why Session-based Recommendations Matters

User behavior is inherently sequential. Consider an e-commerce browsing session:

1. User searches for "wireless headphones"
2. Views a Sony model
3. Checks reviews for Audio-Technica alternatives
4. Compares prices across brands

Each step provides context for the next recommendation. Traditional systems might miss this sequential pattern, while sequence models capture the evolving intent throughout the session.

:::{.column-page}
![Data signals](../static/L2%20-%20Data%20signals.excalidraw.png){.lightbox}
:::

## How to react in real-time: A Simplified Payload Approach

In production, real-time recommendation systems typically leverage **streaming architectures** with event pipelines (Kafka, Kinesis, etc.) that process user interactions. The streaming system is normally built in a centralized manner by a platform team with the aim to provide real-time data processing capabilities to multiple downstream usages. This approach also ensures scalability and reliability.

However, for the purpose of this tutorial, we'll use the **simplified request-payload approach** to focus on the ML aspects rather than streaming infrastructure complexity. 

Basically we would include the real-time events in the payload of the requests coming in to RecSys APIs. In real-world, implementation can be done by frontend capturing user interactions locally (clicks, views, etc.) and includes recent session history in each API request.

While this approach looks like a hacky-workaround ways, I have seen teams using this in production for early-stage real-time ML RecSys. In the end, the idea in and of itself has some merits such as minimal signal delay, users not needing to refresh to get updated recommendations and easier to implement and debug.

In the below screenshot you can see that in the POST request payload sending to a recommendation endpoint, we include the recent user interacted item IDs in `item_seq_raw` in the payload.

:::{.column-page}
![Example request payload](../static/api-payload.png){.lightbox}
:::

## Our Technology Stack

Below is a list of the technology frameworks we use in this project. There is no need to understand all of them in detail, so do not worry too much if you are not familiar. However, I do encourage you to at least learn the basics of each of them. Wherever possible I would also explain the rationale and what roles they play in the system that we build together.

| Component | Technology | Purpose |
|-----------|------------|---------|
| **ML Framework** | PyTorch | Deep learning model training |
| **API Server** | FastAPI | High-performance API endpoints |
| **Experiment Tracking** | MLflow | Model versioning and experiments |
| **Vector Database** | Qdrant | Similarity search and retrieval |
| **Caching** | Redis | Real-time data storage |
| **Package Management** | uv | Fast Python dependency management |
| **Containerization** | Docker | Consistent deployment environments |

## Project Structure Overview

The codebase can be found [here](https://github.com/dvquy13/recsys-seq-model). Below is a quick glance into its structure.

```
recsys-seq-model/
├── notebooks/           # Progressive tutorial notebooks
│   ├── 000-prep-data.ipynb
│   ├── 001-features.ipynb
│   ├── 002-negative-sample.ipynb
│   ├── 010-baseline-popular.ipynb
│   ├── 011-sequence-modeling.ipynb
│   ├── 020-ann-index.ipynb
│   └── 021-redis-prep.ipynb
├── src/                 # Core implementation modules
│   ├── cfg.py          # Configuration management
│   ├── dataset.py      # Data loading utilities  
│   ├── id_mapper.py    # ID mapping functionality
│   ├── negative_sampling.py  # Sampling strategies
│   ├── sequence/       # Sequence model implementations
│   ├── eval/          # Evaluation frameworks
│   └── vectorstore.py # Qdrant integration
├── api/                # FastAPI service
│   ├── app.py         # Main application
│   ├── services.py    # Business logic
│   └── models.py      # Request/response schemas
├── mlflow/            # MLflow configuration
├── data/              # Dataset storage
└── compose.yml        # Docker orchestration
```

### Progressive Notebook Approach

Notice the **numbered notebook sequence** (000, 001, 002, etc.). This design ensures you build knowledge progressively:

- **000-series**: Data preparation and exploration
- **010-series**: Model training and evaluation  
- **020-series**: Production deployment preparation

Each notebook represents a complete milestone, allowing you to pause and resume at any point.

### A note on the commonly used commands

You may found the below commands useful, as I have myself running them regularly when developing the projects. Treating them as shortcuts, I have put them in the Makefile:

```bash
# Environment setup
uv sync --all-groups     # Install/update dependencies
make requirements-txt    # Export requirements for Docker

# Development session
make lab                 # Start Jupyter Lab  # <1>
make ml-platform-up      # Start MLflow, Qdrant, Redis  # <2>
make ml-platform-down    # Stop all services
make ml-platform-logs    # View service logs

# API Operations (covered in later chapters)
make api-up             # Start the FastAPI service
make api-test           # Run API tests

# UI Demo (optional)
make ui-up              # Start the frontend demo
```
1. This is a shortcut to start Jupyter Lab, you will need to run this in every chapter.
2. The tools that we will use to support our model development and serving are grouped into this ml-platform umbrella.

## Recap

To get a hands on the system that we will build together, you can clone the repo and follow the instructions in the README to get the project running.

After that you should have:

- **A clear picture** of what session-based recommendations are and why they're useful
- **Your development environment** ready to go with all services running  
- **Familiarity with the project structure** so you can navigate the codebase  
- **The foundation knowledge** to tackle the upcoming chapters  

## What's Next

Let's get started! Here's an overview of the roadmap ahead of us:

:::{.column-page}
![](../static/dev-roadmap.png){.lightbox}
:::

In [Chapter 2](../c2/index.qmd), we'll get our hands dirty while setting up the input data in a format that's designed for sequence modeling.

Continue to the [next chapter](../c2/index.qmd).

---

<br>
If you find this tutorial helpful, please cite this writeup as:

> Quy, Dinh. (May 2025). {{< meta title >}}. {{< var website_url >}}. https://{{< var website_url >}}/projects/implement-recsys/c1/. 
